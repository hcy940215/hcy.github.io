<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[Kotlin基础-流程控制语句]]></title>
    <url>%2F2019%2F05%2F25%2F</url>
    <content type="text"><![CDATA[流程控制语句​ 流程控制语句是编程语言中常用的核心之一，一般分为以下三类： 分支语句(if、when) 循环语句(for、while) 跳转语句(break、continue、return、throw) if表达式if-else语句是控制程序流程的最基本形式，其中else可选。在kotlin中if是一个表达式，即会有返回值。 代码如下： 1234567891011121314151617181920212223242526fun min(a: Int, b: Int): Int &#123; //if 语句作为表达式 var minValue = if (a &gt; b) b else a return minValue&#125;fun min1(a: Int, b: Int): Int &#123; //if 传统使用 var minValue = a if (a &gt; b) &#123; minValue = b &#125; return minValue&#125;fun min2(a: Int, b: Int): Int &#123; //if else var minValue: Int if (a &gt; b) &#123; minValue = b &#125; else &#123; minValue = a &#125; return minValue&#125; 另外if的分支可以是代码块，最后的表达式作为该块的值： 12345678910111213fun min3(a: Int, b: Int): Int &#123; //if 代码块返回值 var minValue: Int = if (a &gt; b) &#123; println("Min is b") b &#125; else &#123; println("Min is a") a &#125; return minValue&#125; if作为代码块时，最后一行为其返回值。 另外，在kotlin中没有类似 true？1：0这样的三元表达式，对应的写法是if表达式 if(true) 1 else 0。 if-else使用规则： if 后的括号不能省略，括号里表达式的类型须是布尔型； 如果条件体内只有一条语句需要执行，那么if后面的大括号可以省略，建议加上大括号，增加代码可读性； 对于给定的if，else语句是可选的，else if语句也是可选的。 else 和 else if同时出现时，else 必须出现在else if之后； 如果有多条else if语句同时出现，那么如果有一条else if语句的表达式执行，那么会忽略掉其他所有的else if和else分支； 如果同时出现多个if，只有一个else的情形，else子句归属最内层的if语句。 when表达式when表达式类似于swich-case表达式。when会对所有的分支进行检查直到有一个条件满足为止，相比于switch表达式，when表达式更加了灵活，更加强大： 123456789fun whenDemo(obj: Any) &#123; when (obj) &#123; 1 -&gt; println("匹配数字") "Hello" -&gt; println("匹配字符串") is Long -&gt; println("这是一个Long类型") !is String -&gt; println("不是String类型") else -&gt; println(" defult") &#125;&#125; 像if一样，when每个一个分支也可以是一个代码块，它的值是最后的表达式的值。其他分支不满足会执行else分支。如果有多个分支条件需要用相同的方式处理，则可以把多个分支条件放在一起，用逗号隔开： 123456789fun swichDemo(x:Any) &#123; when(x)&#123; 0,1-&gt; print("x=1 or x=0") 2-&gt;print("x=2") else-&gt;&#123; print("other") &#125; &#125;&#125; 可以用表达式作为分支条件, 以及代码块作为值： 1234567891011fun swichDemo(x: Any) &#123; var s = "123" when (x) &#123; 0, 1 -&gt; print("x=1 or x=0") 2 -&gt; print("x=2") Integer.parseInt(s) -&gt; print("x is 123") else -&gt; &#123; print("other") &#125; &#125;&#125; 可以检测一个值在(in)或者不在(!in) 一个区间或者集合中： 1234567891011fun inWhenDemo() &#123; var num = arrayOf(1, 2, 3) var x = 1 when (x) &#123; in 1..10 -&gt; print("x is in the range") in num -&gt; print("x is num") else -&gt; &#123; print("other") &#125; &#125;&#125; for循环for循环与Java中的for循环基本相同。 for循环可以对任意提供迭代器的对象进行遍历，语法如下： 12345var listOf = listOf&lt;Int&gt;(1, 2, 3)for (item in listOf)&#123; print(item)&#125; 通过下标遍历一个数组或者list，可以这样做： 123for ((index, value) in listOf.withIndex()) &#123; println("the element at $index is $value")&#125; 遍历数组： 1234var arrayListOf = arrayListOf&lt;Int&gt;(1, 2, 3)for (index in arrayListOf.indices) &#123; println(arrayListOf[index])&#125; while循环while 和 do/while使用方式与Java 完全一致，代码如下： 1234567891011var x = 10while (x &gt; 0) &#123; x-- println(x)&#125;var y = 10do &#123; y += 1 println(y)&#125; while (y &lt; 20) break 和 continuebreak和contiune都是用来控制循环结构的，break停止循环程序，continue控制中断一次循环程序。 breakbreak用于完全结束一个循环，直接跳出循环体，然后执行循环体后面的语句。 12345678910111213fun breakDemo() &#123; for (i in 1..10) &#123; if (i == 5) &#123; break &#125; println(i) &#125;&#125;1234 continuecontinue终止本轮循环，继续下一次循环。 123456789101112131415161718fun breakDemo1() &#123; for (i in 1..10) &#123; if (i == 5) &#123; continue &#125; println(i) &#125;&#125;1234678910 注意与break的区别。 return在kotlin中，除了表达式的值，又返回值的函数都要求显示地使用return在返回其值，代码中： 1234567891011fun sum1(a: Int, b: Int): Int &#123; return a+b&#125;fun max1(a: Int, b: Int): Int &#123; if (a &gt; b) &#123; return a &#125; else &#123; return b &#125;&#125; 在kotlin中可以直接使用=符号来返回一个函数的值。 123fun sum12(a: Int, b: Int): Int = a + bfun max2(a: Int, b: Int): Int = if (a &gt; b) a else b kotlin中return语句会从最近的函数或匿名函数中返回，但是在lambda表达式中遇到return，则直接返回最近的函数，例如下面的函数： 123456789101112131415161718192021222324252627282930fun returnDemo1() &#123; println("START " + ::returnDemo1.name) var intArrayOf = intArrayOf(1, 2, 3, 4, 5) intArrayOf.forEach &#123; if (it==3) return println(it) &#125; println("END " + ::returnDemo1.name)&#125;START returnDemo112fun returnDemo2() &#123; println("START " + ::returnDemo2.name) var intArrayOf = intArrayOf(1, 2, 3, 4, 5) intArrayOf.forEach(fun(a: Int) &#123; if (a == 3) return println(a) &#125;) println("END " + ::returnDemo2.name)&#125;START returnDemo21245END returnDemo2 观察最后输出结果，在returnDemo1中遇到3直接返回，类似于循环语句中break，在returnDemo2中遇到3会跳过继续执行，类似于循环体中的continue。在returnDemo2中用一个匿名函数代替lambda表达式，匿名函数内部的return语句将从该匿名函数自身返回。在kotlin中，这是匿名函数和lambda表达式不一致的地方。 标签在kotlin中任何表达式都可以用标签(label)来标记。标签的格式为标识符后面跟@符号，例如：abc@,可以用标签来控制return、break、continue的跳转。 有了标签i、限制return，我们可以从外层函数返回了，例如在lambda 中返回，returnDemo2 中可以显示的指定lambda表达式中的return地址是其入口： 12345678910111213141516fun returnDemo3() &#123; println("START " + ::returnDemo3.name) var intArrayOf = intArrayOf(1, 2, 3, 4, 5) intArrayOf.forEach here@&#123; if (it == 3) return@here println(it) &#125; println("END " + ::returnDemo3.name)&#125;START returnDemo31245END returnDemo3 在lambda表达式开头添加了标签here@，该标签相当于是记录了lambda表达式的指令执行入口地址，然后表达式内部使用return@here跳转至lambda表达式该地址处。 也可以使用隐式标签更方便，该标签与接收该lambda 的函数同名。 12345678910111213141516fun returnDemo4() &#123; println("START " + ::returnDemo4.name) var intArrayOf = intArrayOf(1, 2, 3, 4, 5) intArrayOf.forEach&#123; if (it == 3) return@forEach println(it) &#125; println("END " + ::returnDemo4.name)&#125;START returnDemo41245END returnDemo4 接收该lambda表达式的函数是forEach ，所有可以直接使用return@forEach跳转此处执行下一轮循环。 如果双重for循环时直接跳转到外层层循环，也可以使用标签： 12345678910111213141516fun returnDemo5() &#123; outer@ for (i in 1..5) &#123; for (j in 1..5) &#123; println("outer :$i") println("inter :$j") if (j % 2 == 0) &#123; break@outer &#125; &#125; &#125;&#125;outer :1inter :1outer :1inter :2 为了增加代码可读性，可以用标签来指明内层循环的跳转地址： 1234567891011121314151617181920212223242526272829fun returnDemo6() &#123; println("START " + ::returnDemo6.name) for (i in 1..5) &#123; println("outer :$i") inter@ for (j in 1..5) &#123; println("inter :$j") if (j % 2 == 0) &#123; break@inter &#125; &#125; &#125;&#125;START returnDemo6outer :1inter :1inter :2outer :2inter :1inter :2outer :3inter :1inter :2outer :4inter :1inter :2outer :5inter :1inter :2]]></content>
      <tags>
        <tag>kotlin基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Kotlin基础-函数和变量]]></title>
    <url>%2F2019%2F05%2F22%2F</url>
    <content type="text"><![CDATA[函数函数声明​ 函数的声明是以关键字fun 开始，函数名称紧随其后,下面这个例子中函数名称是max,接下来是参数列表，参数列表后面跟这个返回值类型，他们之间用:分开 123fun max(a: Int, b: Int): Int &#123; return if (a &gt; b) a else b&#125; 在kotlin中，if是有结果值的表达式。类似 于kotlin中的三元运算符 (a&gt;b)?a:b。 语句和表达式 ​ 在kotlin中，if是表达式，而不是语句。语句和表达式的区别在于，表达式有值，并且能作为另一个表达式的一部分使用;而语句总是包围着它的代码中的顶层元素，并且没有自己的值。在Java中，所有的控制结构都是语句，而在kotlin中除了(for、do、和do/while)以外大多数控制结构都是表达式。 表达式函数体​ 表达式函数体可以让上面的函数变的更简单，因为它的函数体是由单个表达式构成的，可以用表达式作为函数的函数体，并去掉花括号以及return 语句： 1fun max(a: Int, b: Int) = if (a &gt; b) a else b ​ 每个表达式都有返回类型，但对于表达式函数体来说，编译器会分析作为函数体的表达式，并把它的类型作为函数的返回类型。只有表达式函数的返回类型可以省略，对于有返回值的代码块函数，必须显示地写出返回类型和return 语句。 变量变量声明​ 在kotlin中，一切都是对象。所以变量也是对象。 ​ kotlin 的变量分为var(可变的)和val(不可变的)，可以理解为： var：是可写的，在生命周期内多次赋值。 val：只读的，仅能赋值一次，后面就不能被重新赋值。 123456789101112131415161718192021fun main(arg: Array&lt;String&gt;) &#123; var l = 9L //自动推断出long 类型 l = 67L println(l) println(l::class) println(l::class.java) val b= "b"// b = "string" //报错 ：Val cannot be reassigned println(b) println(b::class) println(b::class.java)&#125;-----------67class kotlin.Longlongbclass kotlin.Stringclass java.lang.String 即使var关键字允许改变自己的值，但是他的类型是改变不了的。例如： 12var answer = 42answer = "Stirng" //编译报错 变量类型推断​ 在kotlin 中大部分情况下不需要声明你使用对象的类型，编译器会直接推断出它的类型， 1234567891011121314151617181920212223242526272829303132 val str = "abc" println(str is String) println(str) println(str::class) println(str::class.java)// true// abc// class kotlin.String// class java.lang.String val bool = true println(bool) println(bool) println(bool::class) println(bool::class.java)// true// class kotlin.Boolean// boolean val array = arrayOf(1,2,3) println(array) println(array is Array) println(array::class) println(array::class.java)// [Ljava.lang.Integer;@c2e1f26// true// class kotlin.Array// class [Ljava.lang.Integer; 编译器能够检测到其类型，自动的完成类型转换，当然也可明确地指定变量类型。但是，类型推断不是所有的，例如，Int类型变量不能赋值Long 1234fun Int2Long()&#123; val a:Int = 10 val b:Long = a //Type mismatch&#125; 需要显示的调用类型转换的函数进行转换 12345fun Int2Long()&#123; val a:Int = 10 val b:Long = a //Type mismatch val b:Long = a.toLong()&#125; 字符串模板​ 原始字符串由三重引号(“””)分隔。原始字符串可以包含换行符和任何其他字符串： 12345678 val string = """hello world 世界 你好 """.trimMargin()------------------------hello world 世界 你好 字符串还可以包含模板表达式，模板表达式以美元符号$ 开始： 1234 val tem = "string has $&#123;string.length&#125; characters" println(tem)------------------------------------ string has 33 characters]]></content>
      <tags>
        <tag>kotlin基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[flutter基础]]></title>
    <url>%2F2019%2F04%2F10%2F</url>
    <content type="text"><![CDATA[flutter 基础as 类型转换 is 当对象是相应类型时返回 true is! 当对象不是相应类型时返回true a = value 赋值 b?? = value 如果b为空，则将值分配给b，否则 b保持不变 ####条件表达式 Condition? Expr1:Expr2 三元表达式 如果expr1 为非空，则返回其值，否则，计算并返回expr2 的值 Expr1？？Expr2 级联操作123querySelector('#btnOK') ..text="确定" ..onclick.listener((e)=&gt;window.alert('确定')) 常用组件容器组件容器组件(Container)包含一个Widget，自身具备alignment、padding等属性，方便布局过程中摆放child，常见属性如下， 属性名 类型 说明 key Key Container唯一标识 alignment AlignmentGeometry 控制child对齐方式，Container或者Container的父节点尺寸大于child的尺寸，这个属性会起作用， padding EdgeInsetsGeometry 内边距 color Color Container背景色，foregroundDecoration设置的话会遮盖color效果 decoration Decoration 绘制在child后面的装饰，设置了Decoration的话，就不能设置color属性，否则会报错，此时应该在Decoration中进行颜色设置 foregroundDecoration Decoration 绘制在child前面的装饰 width double Container的宽度，设置为double.infinity可以强制在宽度上撑满，不设置，则根据child和父节点两者一起布局 height double Container的高度，设置为double.infinity可以强制在高度上撑满 constraints BoxConstraints 添加到child上额外的约束条件 margin EdgeInsetsGeometry 外边距 transform Matrix4 设置Container的变换矩阵，类型为Matri4 child Widget Container中的内容Widget 容器组件示例123456789101112131415161718192021222324252627282930313233343536373839import 'package:flutter/material.dart';void main() =&gt; runApp(new MyApp());class MyApp extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return new MaterialApp( title: '容器组件实例', home: new Scaffold( appBar: new AppBar( title: new Text('容器组件实例'), ), body: new Center( child: Container( width: 200.0, height: 200.0, //添加边框装饰 decoration: BoxDecoration( color: Colors.white, border: new Border.all( color: Colors.grey, width: 8.0, ), //边框的弧度 borderRadius: const BorderRadius.all(const Radius.circular(8.0)), ), child: Text( 'Flutter', textAlign: TextAlign.center, style: TextStyle(fontSize: 28.0), ), ), ), ), ); &#125;&#125; 图片组件图片组件(Image)是显示图像的组件，Image组件有多种构造函数： new Image:从ImageProvider获取图像。 new Image.asset:加载资源图片。 new Image.file:加载本地图片。 new Image.network:加载网络图片。 new Image.memory:加载Unit8List资源图片。 属性名 类型 说明 Width/height ImageProvider 获取数据 fit double 图片填充模式 colorBlendMode BlendMode 对颜色混合处理 alignment Alignment 控制图片摆放位置 repeat ImageRepeat 设置图片重复模式 centerSlice Rect 当图片需要被拉伸显示时，centerSlice定义矩形区域会被拉伸， matchTextDirection bool matchTextDirection与Directionality配合使用，TextDirection有两个值分别为：TextDirection.ltr 从左到右展示图片，TextDirection.rtl从右到左展示图片 gaplessPlayback bool 当ImageProvider发生变化后，重新加载图片的过程中，原图片的展示是否保留，false不保留，直接空白等待下一张图片加载 ######图片组件示例 12345678910111213//图片组件class ImageDemo extends StatelessWidget &#123; @override Widget build(BuildContext context) &#123; return new MaterialApp( title: &apos;图片组件实例&apos;, home: new Container( child: new Image.network( &apos;https://timgsa.baidu.com/timg?image&amp;quality=80&amp;size=b9999_10000&amp;sec=1555047028590&amp;di=b735c56cef3184fe82412264cfff228c&amp;imgtype=0&amp;src=http%3A%2F%2Fb-ssl.duitang.com%2Fuploads%2Fitem%2F201504%2F03%2F20150403H1232_RJ2iV.jpeg&apos;, fit: BoxFit.fitWidth, ))); &#125;&#125; 文本组件文本组件(text)负责显示文本和定义显示样式，属性表 属性名 类型 默认值 说明]]></content>
  </entry>
</search>
